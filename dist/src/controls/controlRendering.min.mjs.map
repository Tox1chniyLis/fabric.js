{"version":3,"file":"controlRendering.min.mjs","sources":["../../../src/controls/controlRendering.ts"],"sourcesContent":["import { FILL, STROKE, twoMathPi } from '../constants';\nimport type { InteractiveFabricObject } from '../shapes/Object/InteractiveObject';\nimport { degreesToRadians } from '../util/misc/radiansDegreesConversion';\nimport type { Control } from './Control';\n\nexport type ControlRenderingStyleOverride = Partial<\n  Pick<\n    InteractiveFabricObject,\n    | 'cornerStyle'\n    | 'cornerSize'\n    | 'cornerColor'\n    | 'cornerStrokeColor'\n    | 'cornerDashArray'\n    | 'transparentCorners' \n    | 'cornerSecondColor'\n  >\n>;\n\nexport type ControlRenderer<\n  O extends InteractiveFabricObject = InteractiveFabricObject,\n> = (\n  ctx: CanvasRenderingContext2D,\n  left: number,\n  top: number,\n  styleOverride: ControlRenderingStyleOverride,\n  fabricObject: O,\n) => void;\n\nexport function renderPointControl(\n    this: Control,\n    ctx: CanvasRenderingContext2D,\n    left: number,\n    top: number,\n    styleOverride: ControlRenderingStyleOverride,\n    fabricObject: InteractiveFabricObject\n  ) {\n    styleOverride = styleOverride || {};\n    const xSize =\n      this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize;\n    const ySize =\n      this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize;\n\n    let myLeft = left;\n    let myTop = top;\n    let size = undefined;\n\n    ctx.save();\n    ctx.fillStyle =\n      styleOverride.cornerSecondColor || fabricObject.cornerSecondColor;\n    ctx.strokeStyle =\n      styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor || \"\";\n\n    if (xSize > ySize) {\n      size = xSize;\n      ctx.scale(1.0, ySize / xSize);\n      myTop = (top * xSize) / ySize;\n    } else if (ySize > xSize) {\n      size = ySize;\n      ctx.scale(xSize / ySize, 1.0);\n      myLeft = (left * ySize) / xSize;\n    } else {\n      size = xSize;\n    }\n\n    ctx.beginPath();\n    ctx.arc(myLeft, myTop, size / 1.5, 0, Math.PI * 2, false);\n    ctx.fill();\n\n    ctx.closePath();\n\n    ctx.arc(myLeft, myTop, size / 1.5, 0, Math.PI * 2, false);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  export function renderRoundedPointControl(\n    this: Control,\n    ctx: CanvasRenderingContext2D,\n    left: number,\n    top: number,\n    styleOverride: ControlRenderingStyleOverride,\n    fabricObject: InteractiveFabricObject\n  ) {\n    styleOverride = styleOverride || {};\n    const xSize =\n      this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize;\n    const ySize =\n      this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize;\n\n    let myLeft = left;\n    let myTop = top;\n    let size = undefined;\n\n    ctx.save();\n    ctx.fillStyle =\n      styleOverride.cornerSecondColor || fabricObject.cornerSecondColor;\n    ctx.strokeStyle =\n      styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor || \"\";\n\n    if (xSize > ySize) {\n      size = xSize;\n      ctx.scale(1.0, ySize / xSize);\n      myTop = (top * xSize) / ySize;\n    } else if (ySize > xSize) {\n      size = ySize;\n      ctx.scale(xSize / ySize, 1.0);\n      myLeft = (left * ySize) / xSize;\n    } else {\n      size = xSize;\n    }\n\n    ctx.beginPath();\n\n    ctx.fillStyle =\n      styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor || \"\";\n\n    ctx.arc(myLeft, myTop, size / 1, 0, Math.PI * 2, false);\n    ctx.fill();\n\n    ctx.closePath();\n\n    ctx.beginPath();\n\n    ctx.fillStyle =\n      styleOverride.cornerSecondColor || fabricObject.cornerSecondColor || \"\";\n\n    ctx.arc(myLeft, myTop, size / 2, 0, Math.PI * 2, false);\n    ctx.fill();\n\n    ctx.closePath();\n    ctx.beginPath();\n\n    ctx.strokeStyle =\n      styleOverride.cornerSecondColor || fabricObject.cornerSecondColor || \"\";\n\n    ctx.arc(myLeft, myTop, size / 1.2, 0, Math.PI * 2, false);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n/**\n * Render a round control, as per fabric features.\n * This function is written to respect object properties like transparentCorners, cornerSize\n * cornerColor, cornerStrokeColor\n * plus the addition of offsetY and offsetX.\n * @param {CanvasRenderingContext2D} ctx context to render on\n * @param {Number} left x coordinate where the control center should be\n * @param {Number} top y coordinate where the control center should be\n * @param {Object} styleOverride override for FabricObject controls style\n * @param {FabricObject} fabricObject the fabric object for which we are rendering controls\n */\nexport function renderCircleControl(\n  this: Control,\n  ctx: CanvasRenderingContext2D,\n  left: number,\n  top: number,\n  styleOverride: ControlRenderingStyleOverride,\n  fabricObject: InteractiveFabricObject,\n) {\n  styleOverride = styleOverride || {};\n  const xSize =\n      this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize,\n    ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize,\n    transparentCorners =\n      typeof styleOverride.transparentCorners !== 'undefined'\n        ? styleOverride.transparentCorners\n        : fabricObject.transparentCorners,\n    methodName = transparentCorners ? STROKE : FILL,\n    stroke =\n      !transparentCorners &&\n      (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor);\n  let myLeft = left,\n    myTop = top,\n    size;\n  ctx.save();\n  ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor || '';\n  ctx.strokeStyle =\n    styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor || '';\n  // TODO: use proper ellipse code.\n  if (xSize > ySize) {\n    size = xSize;\n    ctx.scale(1.0, ySize / xSize);\n    myTop = (top * xSize) / ySize;\n  } else if (ySize > xSize) {\n    size = ySize;\n    ctx.scale(xSize / ySize, 1.0);\n    myLeft = (left * ySize) / xSize;\n  } else {\n    size = xSize;\n  }\n  ctx.beginPath();\n  ctx.arc(myLeft, myTop, size / 2, 0, twoMathPi, false);\n  ctx[methodName]();\n  if (stroke) {\n    ctx.stroke();\n  }\n  ctx.restore();\n} \n\n/**\n * Render a square control, as per fabric features.\n * This function is written to respect object properties like transparentCorners, cornerSize\n * cornerColor, cornerStrokeColor\n * plus the addition of offsetY and offsetX.\n * @param {CanvasRenderingContext2D} ctx context to render on\n * @param {Number} left x coordinate where the control center should be\n * @param {Number} top y coordinate where the control center should be\n * @param {Object} styleOverride override for FabricObject controls style\n * @param {FabricObject} fabricObject the fabric object for which we are rendering controls\n */\nexport function renderSquareControl(\n  this: Control,\n  ctx: CanvasRenderingContext2D,\n  left: number,\n  top: number,\n  styleOverride: ControlRenderingStyleOverride,\n  fabricObject: InteractiveFabricObject,\n) {\n  styleOverride = styleOverride || {};\n  const xSize =\n      this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize,\n    ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize,\n    transparentCorners =\n      typeof styleOverride.transparentCorners !== 'undefined'\n        ? styleOverride.transparentCorners\n        : fabricObject.transparentCorners,\n    methodName = transparentCorners ? STROKE : FILL,\n    stroke =\n      !transparentCorners &&\n      (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor),\n    xSizeBy2 = xSize / 2,\n    ySizeBy2 = ySize / 2;\n  ctx.save();\n  ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor || '';\n  ctx.strokeStyle =\n    styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor || '';\n  ctx.translate(left, top);\n  //  angle is relative to canvas plane\n  const angle = fabricObject.getTotalAngle();\n  ctx.rotate(degreesToRadians(angle));\n  // this does not work, and fixed with ( && ) does not make sense.\n  // to have real transparent corners we need the controls on upperCanvas\n  // transparentCorners || ctx.clearRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n  ctx[`${methodName}Rect`](-xSizeBy2, -ySizeBy2, xSize, ySize);\n  if (stroke) {\n    ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);\n  }\n  ctx.restore();\n}\n"],"names":["renderPointControl","ctx","left","top","styleOverride","fabricObject","xSize","this","sizeX","cornerSize","ySize","sizeY","size","myLeft","myTop","save","fillStyle","cornerSecondColor","strokeStyle","cornerStrokeColor","scale","beginPath","arc","Math","PI","fill","closePath","stroke","restore","renderRoundedPointControl","renderCircleControl","transparentCorners","methodName","STROKE","FILL","cornerColor","twoMathPi","renderSquareControl","xSizeBy2","ySizeBy2","translate","angle","getTotalAngle","rotate","degreesToRadians","concat","strokeRect"],"mappings":"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"}