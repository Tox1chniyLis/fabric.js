{"version":3,"file":"util.mjs","sources":["../../../src/controls/util.ts"],"sourcesContent":["import type {\n  TPointerEvent,\n  Transform,\n  TransformAction,\n  BasicTransformEvent,\n} from '../EventTypeDefs';\nimport { resolveOrigin } from '../util/misc/resolveOrigin';\nimport { Point } from '../Point';\nimport type { FabricObject } from '../shapes/Object/FabricObject';\nimport type { TOriginX, TOriginY } from '../typedefs';\nimport {\n  degreesToRadians,\n  radiansToDegrees,\n} from '../util/misc/radiansDegreesConversion';\nimport type { Control } from './Control';\nimport { CENTER } from '../constants';\n\nexport const NOT_ALLOWED_CURSOR = 'not-allowed';\n\n/**\n * @param {Boolean} alreadySelected true if target is already selected\n * @param {String} corner a string representing the corner ml, mr, tl ...\n * @param {Event} e Event object\n * @param {FabricObject} [target] inserted back to help overriding. Unused\n */\nexport const getActionFromCorner = (\n  alreadySelected: boolean,\n  corner: string | undefined,\n  e: TPointerEvent,\n  target: FabricObject,\n) => {\n  if (!corner || !alreadySelected) {\n    return 'drag';\n  }\n  const control = target.controls[corner];\n  return control.getActionName(e, control, target);\n};\n\n/**\n * Checks if transform is centered\n * @param {Object} transform transform data\n * @return {Boolean} true if transform is centered\n */\nexport function isTransformCentered(transform: Transform) {\n  return (\n    resolveOrigin(transform.originX) === resolveOrigin(CENTER) &&\n    resolveOrigin(transform.originY) === resolveOrigin(CENTER)\n  );\n}\n\nexport function invertOrigin(origin: TOriginX | TOriginY) {\n  return -resolveOrigin(origin) + 0.5;\n}\n\nexport const isLocked = (\n  target: FabricObject,\n  lockingKey:\n    | 'lockMovementX'\n    | 'lockMovementY'\n    | 'lockRotation'\n    | 'lockScalingX'\n    | 'lockScalingY'\n    | 'lockSkewingX'\n    | 'lockSkewingY'\n    | 'lockScalingFlip',\n) => target[lockingKey];\n\nexport const commonEventInfo: TransformAction<\n  Transform,\n  BasicTransformEvent\n> = (eventData, transform, x, y) => {\n  return {\n    e: eventData,\n    transform,\n    pointer: new Point(x, y),\n  };\n};\n\n/**\n * Combine control position and object angle to find the control direction compared\n * to the object center.\n * @param {FabricObject} fabricObject the fabric object for which we are rendering controls\n * @param {Control} control the control class\n * @return {Number} 0 - 7 a quadrant number\n */\nexport function findCornerQuadrant(\n  fabricObject: FabricObject,\n  control: Control,\n): number {\n  //  angle is relative to canvas plane\n  const angle = fabricObject.getTotalAngle(),\n    cornerAngle =\n      angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;\n  return Math.round((cornerAngle % 360) / 45);\n}\n\n/**\n * @returns the normalized point (rotated relative to center) in local coordinates\n */\nfunction normalizePoint(\n  target: FabricObject,\n  point: Point,\n  originX: TOriginX,\n  originY: TOriginY,\n): Point {\n  const center = target.getRelativeCenterPoint(),\n    p =\n      typeof originX !== 'undefined' && typeof originY !== 'undefined'\n        ? target.translateToGivenOrigin(\n            center,\n            CENTER,\n            CENTER,\n            originX,\n            originY,\n          )\n        : new Point(target.left, target.top),\n    p2 = target.angle\n      ? point.rotate(-degreesToRadians(target.angle), center)\n      : point;\n  return p2.subtract(p);\n}\n\n/**\n * Transforms a point to the offset from the given origin\n * @param {Object} transform\n * @param {String} originX\n * @param {String} originY\n * @param {number} x\n * @param {number} y\n * @return {Fabric.Point} the normalized point\n */\nexport function getLocalPoint(\n  { target, corner }: Transform,\n  originX: TOriginX,\n  originY: TOriginY,\n  x: number,\n  y: number,\n) {\n  const control = target.controls[corner],\n    zoom = target.canvas?.getZoom() || 1,\n    padding = target.padding / zoom,\n    localPoint = normalizePoint(target, new Point(x, y), originX, originY);\n  if (localPoint.x >= padding) {\n    localPoint.x -= padding;\n  }\n  if (localPoint.x <= -padding) {\n    localPoint.x += padding;\n  }\n  if (localPoint.y >= padding) {\n    localPoint.y -= padding;\n  }\n  if (localPoint.y <= padding) {\n    localPoint.y += padding;\n  }\n  localPoint.x -= control.offsetX;\n  localPoint.y -= control.offsetY;\n  return localPoint;\n}\n"],"names":["NOT_ALLOWED_CURSOR","getActionFromCorner","alreadySelected","corner","e","target","control","controls","getActionName","isTransformCentered","transform","resolveOrigin","originX","CENTER","originY","invertOrigin","origin","isLocked","lockingKey","commonEventInfo","eventData","x","y","pointer","Point","findCornerQuadrant","fabricObject","angle","getTotalAngle","cornerAngle","radiansToDegrees","Math","atan2","round","normalizePoint","point","center","getRelativeCenterPoint","p","translateToGivenOrigin","left","top","p2","rotate","degreesToRadians","subtract","getLocalPoint","_ref","_target$canvas","zoom","canvas","getZoom","padding","localPoint","offsetX","offsetY"],"mappings":";;;;;AAiBO,MAAMA,kBAAkB,GAAG;;AAElC;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,mBAAmB,GAAGA,CACjCC,eAAwB,EACxBC,MAA0B,EAC1BC,CAAgB,EAChBC,MAAoB,KACjB;AACH,EAAA,IAAI,CAACF,MAAM,IAAI,CAACD,eAAe,EAAE;AAC/B,IAAA,OAAO,MAAM;AACf;AACA,EAAA,MAAMI,OAAO,GAAGD,MAAM,CAACE,QAAQ,CAACJ,MAAM,CAAC;EACvC,OAAOG,OAAO,CAACE,aAAa,CAACJ,CAAC,EAAEE,OAAO,EAAED,MAAM,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACO,SAASI,mBAAmBA,CAACC,SAAoB,EAAE;EACxD,OACEC,aAAa,CAACD,SAAS,CAACE,OAAO,CAAC,KAAKD,aAAa,CAACE,MAAM,CAAC,IAC1DF,aAAa,CAACD,SAAS,CAACI,OAAO,CAAC,KAAKH,aAAa,CAACE,MAAM,CAAC;AAE9D;AAEO,SAASE,YAAYA,CAACC,MAA2B,EAAE;AACxD,EAAA,OAAO,CAACL,aAAa,CAACK,MAAM,CAAC,GAAG,GAAG;AACrC;AAEO,MAAMC,QAAQ,GAAGA,CACtBZ,MAAoB,EACpBa,UAQqB,KAClBb,MAAM,CAACa,UAAU;AAEf,MAAMC,eAGZ,GAAGA,CAACC,SAAS,EAAEV,SAAS,EAAEW,CAAC,EAAEC,CAAC,KAAK;EAClC,OAAO;AACLlB,IAAAA,CAAC,EAAEgB,SAAS;IACZV,SAAS;AACTa,IAAAA,OAAO,EAAE,IAAIC,KAAK,CAACH,CAAC,EAAEC,CAAC;GACxB;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASG,kBAAkBA,CAChCC,YAA0B,EAC1BpB,OAAgB,EACR;AACR;AACA,EAAA,MAAMqB,KAAK,GAAGD,YAAY,CAACE,aAAa,EAAE;AACxCC,IAAAA,WAAW,GACTF,KAAK,GAAGG,gBAAgB,CAACC,IAAI,CAACC,KAAK,CAAC1B,OAAO,CAACgB,CAAC,EAAEhB,OAAO,CAACe,CAAC,CAAC,CAAC,GAAG,GAAG;EACpE,OAAOU,IAAI,CAACE,KAAK,CAAEJ,WAAW,GAAG,GAAG,GAAI,EAAE,CAAC;AAC7C;;AAEA;AACA;AACA;AACA,SAASK,cAAcA,CACrB7B,MAAoB,EACpB8B,KAAY,EACZvB,OAAiB,EACjBE,OAAiB,EACV;AACP,EAAA,MAAMsB,MAAM,GAAG/B,MAAM,CAACgC,sBAAsB,EAAE;AAC5CC,IAAAA,CAAC,GACC,OAAO1B,OAAO,KAAK,WAAW,IAAI,OAAOE,OAAO,KAAK,WAAW,GAC5DT,MAAM,CAACkC,sBAAsB,CAC3BH,MAAM,EACNvB,MAAM,EACNA,MAAM,EACND,OAAO,EACPE,OACF,CAAC,GACD,IAAIU,KAAK,CAACnB,MAAM,CAACmC,IAAI,EAAEnC,MAAM,CAACoC,GAAG,CAAC;IACxCC,EAAE,GAAGrC,MAAM,CAACsB,KAAK,GACbQ,KAAK,CAACQ,MAAM,CAAC,CAACC,gBAAgB,CAACvC,MAAM,CAACsB,KAAK,CAAC,EAAES,MAAM,CAAC,GACrDD,KAAK;AACX,EAAA,OAAOO,EAAE,CAACG,QAAQ,CAACP,CAAC,CAAC;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASQ,aAAaA,CAAAC,IAAA,EAE3BnC,OAAiB,EACjBE,OAAiB,EACjBO,CAAS,EACTC,CAAS,EACT;AAAA,EAAA,IAAA0B,cAAA;EAAA,IALA;IAAE3C,MAAM;AAAEF,IAAAA;AAAkB,GAAC,GAAA4C,IAAA;AAM7B,EAAA,MAAMzC,OAAO,GAAGD,MAAM,CAACE,QAAQ,CAACJ,MAAM,CAAC;AACrC8C,IAAAA,IAAI,GAAG,CAAAD,CAAAA,cAAA,GAAA3C,MAAM,CAAC6C,MAAM,MAAA,IAAA,IAAAF,cAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAbA,cAAA,CAAeG,OAAO,EAAE,KAAI,CAAC;AACpCC,IAAAA,OAAO,GAAG/C,MAAM,CAAC+C,OAAO,GAAGH,IAAI;AAC/BI,IAAAA,UAAU,GAAGnB,cAAc,CAAC7B,MAAM,EAAE,IAAImB,KAAK,CAACH,CAAC,EAAEC,CAAC,CAAC,EAAEV,OAAO,EAAEE,OAAO,CAAC;AACxE,EAAA,IAAIuC,UAAU,CAAChC,CAAC,IAAI+B,OAAO,EAAE;IAC3BC,UAAU,CAAChC,CAAC,IAAI+B,OAAO;AACzB;AACA,EAAA,IAAIC,UAAU,CAAChC,CAAC,IAAI,CAAC+B,OAAO,EAAE;IAC5BC,UAAU,CAAChC,CAAC,IAAI+B,OAAO;AACzB;AACA,EAAA,IAAIC,UAAU,CAAC/B,CAAC,IAAI8B,OAAO,EAAE;IAC3BC,UAAU,CAAC/B,CAAC,IAAI8B,OAAO;AACzB;AACA,EAAA,IAAIC,UAAU,CAAC/B,CAAC,IAAI8B,OAAO,EAAE;IAC3BC,UAAU,CAAC/B,CAAC,IAAI8B,OAAO;AACzB;AACAC,EAAAA,UAAU,CAAChC,CAAC,IAAIf,OAAO,CAACgD,OAAO;AAC/BD,EAAAA,UAAU,CAAC/B,CAAC,IAAIhB,OAAO,CAACiD,OAAO;AAC/B,EAAA,OAAOF,UAAU;AACnB;;;;"}