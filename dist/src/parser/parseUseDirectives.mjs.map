{"version":3,"file":"parseUseDirectives.mjs","sources":["../../../src/parser/parseUseDirectives.ts"],"sourcesContent":["import { svgNS } from './constants';\nimport { getMultipleNodes } from './getMultipleNodes';\nimport { applyViewboxTransform } from './applyViewboxTransform';\nimport { parseStyleString } from './parseStyleString';\n\nexport function parseUseDirectives(doc: Document) {\n  const nodelist = getMultipleNodes(doc, ['use', 'svg:use']);\n  const skipAttributes = ['x', 'y', 'xlink:href', 'href', 'transform'];\n\n  for (const useElement of nodelist) {\n    const useAttributes: NamedNodeMap = useElement.attributes;\n\n    const useAttrMap: Record<string, string> = {};\n    for (const attr of useAttributes) {\n      attr.value && (useAttrMap[attr.name] = attr.value);\n    }\n\n    const xlink = (useAttrMap['xlink:href'] || useAttrMap.href || '').slice(1);\n\n    if (xlink === '') {\n      return;\n    }\n    const referencedElement = doc.getElementById(xlink);\n    if (referencedElement === null) {\n      // if we can't find the target of the xlink, consider this use tag bad, similar to no xlink\n      return;\n    }\n    let clonedOriginal = referencedElement.cloneNode(true) as Element;\n\n    const originalAttributes: NamedNodeMap = clonedOriginal.attributes;\n\n    const originalAttrMap: Record<string, string> = {};\n    for (const attr of originalAttributes) {\n      attr.value && (originalAttrMap[attr.name] = attr.value);\n    }\n\n    // Transform attribute needs to be merged in a particular way\n    const { x = 0, y = 0, transform = '' } = useAttrMap;\n    const currentTrans = `${transform} ${\n      originalAttrMap.transform || ''\n    } translate(${x}, ${y})`;\n\n    applyViewboxTransform(clonedOriginal);\n\n    if (/^svg$/i.test(clonedOriginal.nodeName)) {\n      // if is an SVG, create a group and apply all the attributes on top of it\n      const el3 = clonedOriginal.ownerDocument.createElementNS(svgNS, 'g');\n      Object.entries(originalAttrMap).forEach(([name, value]) =>\n        el3.setAttributeNS(svgNS, name, value),\n      );\n      el3.append(...clonedOriginal.childNodes);\n      clonedOriginal = el3;\n    }\n\n    for (const attr of useAttributes) {\n      if (!attr) {\n        continue;\n      }\n      const { name, value } = attr;\n      if (skipAttributes.includes(name)) {\n        continue;\n      }\n\n      if (name === 'style') {\n        // when use has a style, merge the two styles, with the ref being priority (not use)\n        // priority is by feature. an attribute for fill on the original element\n        // will overwrite the fill in style or attribute for tha use\n        const styleRecord: Record<string, any> = {};\n        parseStyleString(value!, styleRecord);\n        // cleanup styleRecord from attributes of original\n        Object.entries(originalAttrMap).forEach(([name, value]) => {\n          styleRecord[name] = value;\n        });\n        // now we can put in the style of the original that will overwrite the original attributes\n        parseStyleString(originalAttrMap.style || '', styleRecord);\n        const mergedStyles = Object.entries(styleRecord)\n          .map((entry) => entry.join(':'))\n          .join(';');\n        clonedOriginal.setAttribute(name, mergedStyles);\n      } else {\n        // set the attribute from use element only if the original does not have it already\n        !originalAttrMap[name] && clonedOriginal.setAttribute(name, value!);\n      }\n    }\n\n    clonedOriginal.setAttribute('transform', currentTrans);\n    clonedOriginal.setAttribute('instantiated_by_use', '1');\n    clonedOriginal.removeAttribute('id');\n    useElement.parentNode!.replaceChild(clonedOriginal, useElement);\n  }\n}\n"],"names":["parseUseDirectives","doc","nodelist","getMultipleNodes","skipAttributes","useElement","useAttributes","attributes","useAttrMap","attr","value","name","xlink","href","slice","referencedElement","getElementById","clonedOriginal","cloneNode","originalAttributes","originalAttrMap","x","y","transform","currentTrans","concat","applyViewboxTransform","test","nodeName","el3","ownerDocument","createElementNS","svgNS","Object","entries","forEach","_ref","setAttributeNS","append","childNodes","includes","styleRecord","parseStyleString","_ref2","style","mergedStyles","map","entry","join","setAttribute","removeAttribute","parentNode","replaceChild"],"mappings":"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"}